/*
function call: main -> DFS -> main

1. 이동할 말 고르기
- 순열로 뽑고, 특정 말을 뽑을 수 없는 경우도 구현

2. 이동위치 계산
- 진행 방향이 중간에 바뀔 수 있고, 같은 점수인 판이 여러 개 있기도 하므로(16, 28, 26, 30점)
  점수를 인덱스로 삼기 어려움
- 그래서 모든 위치에 별도로 인덱스를 만듦 (score 배열)
- 행:기존 위치, 열:주사위 눈금, 값: 이 다음에 이동할 위치  를 담은 2차원 배열 만듦(table)
*/
#include <iostream>
using namespace std;

// 21: 도착
int score[33] = {0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 0, 13, 16, 19, 22, 24, 28, 27, 26, 25, 30, 35};
int table[33][5] = {
	{1, 2, 3, 4, 5},
	{2, 3, 4, 5, 6},
	{3, 4, 5, 6, 7},
	{4, 5, 6, 7, 8},
	{5, 6, 7, 8, 9},
	{22, 23, 24, 30, 31}, // 점수 10에서 출발
	{7, 8, 9, 10, 11},
	{8, 9, 10, 11, 12},
	{9, 10, 11, 12, 13},
	{10, 11, 12, 13, 14},
	{25, 26, 30, 31, 32}, // 점수 20에서 출발
	{12, 13, 14, 15, 16},
	{13, 14, 15, 16, 17},
	{14, 15, 16, 17, 18},
	{15, 16, 17, 18, 19},
	{27, 28, 29, 30, 31}, // 점수 30에서 출발
	{17, 18, 19, 20, 21},
	{18, 19, 20, 21, 21},
	{19, 20, 21, 21, 21},
	{20, 21, 21, 21, 21},
	{21, 21, 21, 21, 21}, // 점수 40에서 출발
	{21, 21, 21, 21, 21},
	{23, 24, 30, 31, 32}, // 점수 13에서 출발 (22)
	{24, 30, 31, 32, 20},
	{30, 31, 32, 20, 21},
	{26, 30, 31, 32, 20},
	{30, 31, 32, 20, 21},
	{28, 29, 30, 31, 32},
	{29, 30, 31, 32, 20},
	{30, 31, 32, 20, 21},
	{31, 32, 20, 21, 21},
	{32, 20, 21, 21, 21},
	{20, 21, 21, 21, 21}
};

int cube[10]; // 주사위 눈금
int horse[4]; // 각 말의 위치
int visited[33];

int answer;
int sumScore;

void DFS(int cnt) {
	if (cnt >= 10) {

		if (sumScore > answer) answer = sumScore;

		return;
	}

	for (int i = 0; i < 4; i++) {
		// i번 말을 고를 수 있는지 검증
		if (horse[i] == 21) continue; // 이미 도착한 말은 고를 수 없다
		int nextPos = table[horse[i]][cube[cnt]]; // i번 말을 이번에 고르면 도착하게 될 위치
		if (nextPos != 21 && visited[nextPos] != 0) continue; // 도착할 곳에 이미 누가 있으면 안된다

		// i번 말을 움직이기
		int origin = horse[i];
		visited[horse[i]] = 0;
		horse[i] = nextPos;
		visited[horse[i]] = i+1; // i로 하면 방문 안함(0)과 첫번째 말이 방문함(0)이 겹침
		sumScore += score[horse[i]];

		DFS(cnt + 1);

		// i번 말 되돌려놓기
		sumScore -= score[horse[i]];
		visited[horse[i]] = 0;
		horse[i] = origin;
		visited[horse[i]] = i+1;
	}
}

int main() { 

	for (int i = 0; i < 10; i++) {
		scanf("%d ", &cube[i]);
		cube[i]--;
	}

	DFS(0);

	cout << answer;

	return 0;
}